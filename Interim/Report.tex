\documentclass[a4paper, 12pt]{article}
\usepackage[a4paper]{geometry}
\usepackage{cite}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage{hyperref}

% Set the images directory
\graphicspath{{images/}}

% Show links in the TOC
\hypersetup{hidelinks}

% Disable line breaks
\setlength\righthyphenmin{62}
\setlength\lefthyphenmin{62}

% Disable paragraph breaks
\widowpenalties 1 10000

% Start writing the document
\begin{document}

% Title page
\title{
	{Cloud Game Engine}\\
	\large{Interim Report}\\
	% \large{Dublin Institute of Technology}\\
	% Student Number: C11426252\\
	% Supervisor: Brian Keegan
	% TODO
	% http://alvinalexander.com/blog/post/latex/reference-figure-or-table-within-latex-document
}
\author{Declan Curran}
\maketitle
\newpage

% Table of Contents
\setcounter{tocdepth}{3}
\tableofcontents
\newpage

% Document contents
\section{Project Statement}
\section{Research}
\subsection{Background Research}

Web-based applications are becoming increasingly popular as the web develops; they are often favoured over traditional desktop applications when it comes to things like writing documents (Google Drive, Office Live) or backing up files.\cite{6068340} Desktop applications will often require downloading large installation files, dependencies (Java, .NET), and can often be limited to a single platform. Web apps are now becoming the norm, as they are far more flexible, can be updated or distributed instantly and are almost entirely cross platform.\cite{5936687}

According to Taivalsaari and Mikkonen, ``Towards the end of this decade, the Web will become the dominant platform for the majority of 
end user software''.\cite{6068340} It's only a matter of time until game engine suites such as Unity\cite{unity}, CryEngine\cite{cryengine} and Unreal Engine\cite{unreal} adapt to the web. Creating a web application in this area now will make it easier for new game developers to get started on building games without having to download software. This also eases game publishing significantly by allowing users to publish their games instantly to the cloud with a single click.

WebGL is an open-source API for rendering 3D graphics in the browser, which is based on OpenGL ES; a commonly used graphics processing API that powers 3D graphics on the iPhone, iPad and Android devices.\cite{parisi2012webgl} WebGL is quickly becoming ``the new standard for 3D graphics on the Web''\cite[p2]{parisi2012webgl} as it is the most powerful and flexible way to render graphics in-browser without any extra dependencies or plugins needed. The JavaScript programming language is used to access the WebGL API, which can be rather complicated to program with; ``To do anything more than the most basic tasks using [WebGL] out of the box requires serious effort and literally hundreds of lines of code.''\cite[p44]{parisi2014programming}

The solution to the WebGL API's complexity is to use a library that wraps it and simplifies the interface. The Three.js\cite{threejs} JavaScript library accomplishes this by providing easy to use classes such as models, lighting, scenes and cameras. ``A program written in raw WebGL style using hundreds of lines of code can be expressed in just a few dozen lines of code with Three.js.''\cite[p57]{parisi2014programming} While Three.js greatly simplifies the process of rendering scenes in the browser, it's not good enough for the development of games, as it only provides a framework for rendering scenes without any game logic.

The architecture of the game engine is critical to how accessible it is to developers. The Entity-Component-System is a pattern that can simplify how game objects are defined by separating behaviour into smaller components. Each empty game object can be made up of many components, which will add up to produce a dynamic and interesting object, for example; a blank `cube' object could have a model component, giving it something to render, and a physics component which will allow it to collide with the world and other physics objects.\cite{gregory2014game} This pattern essentially reduces game objects from what would normally be a class inherited from a base object, to a list of components and properties.

An ECS-based game engine with an integrated editor will give users the power to build games even with minimal programming knowledge. A good example of this is Unity, which allows users to build their games just by creating their scene, adding entities such as a floor, and adding physics components to those entities.\cite{unitycreatingscenes} Adding a controller such as the `First Person Controller' to their project allows the player to input and explore the scene just like in a standard first person shooter game.\cite{unitycharactercontrol}

\subsection{Alternative Existing Solutions}
\subsubsection{Unity}
Unity is a 3D game engine with an integrated editor and a huge online library full of assets such as models, sounds and various scripts or tools. Unity is a cross-platform engine that is used on Windows, Linux, Mac OSX, mobiles (Android, iOS, Windows, BlackBerry), consoles (PS3, Xbox360, Wii U) and even in browsers.\cite{unity}

Unity's ability to publish games to the web via the Unity Web Player browser plugin make it a powerful solution to creating games for the web. The only downside to the web player is that the user must install the runtime plugin to be able to play.\cite{unityweb}

The Unity game engine is based on the Entity-Component-System pattern, with the majority of components used being supplied by the engine (Such as lighting, physics, models).\cite{unitycomponents} Unity games can be scripted in one of three languages; C\#, Boo or JavaScript.

The Unity scene editor allows complex entities to be created simply by adding a number of components to an empty entity from a list. The properties for each component can then be edited in the \emph{properties inspector}, such as changing the model or colour of an object. \cite{unitycreatingscenes}

% Add pic of inspector

\subsubsection{PlayCanvas}
PlayCanvas is a browser based game engine and editor with cloud storage. 

% TODO
% Ref: https://playcanvas.com

\subsubsection{CopperLicht}
\begin{quote}
CopperLicht is an open source WebGL library and JavaScript 3D engine for creating games and 3D applications in the webbrowser. It uses the WebGL canvas supported by modern browsers and is able to render hardware accelerated 3d graphics without any plugins.\cite{copperlicht}
\end{quote}

The CopperLicht game engine uses an OOP style approach to the architecture of a game, with entities being defined via scripting rather than by selecting a group of components as Unity does. The CopperLicht engine will handle rendering, physics and animations, any extra functionality must be added manually by the user with a script.\cite{copperlichtfeatures}

The CopperLicht world editor, \emph{CopperCube} is an editor designed to create the worlds used in a CopperLicht game. It works by generating a scene file which is loaded by a HTML file, generated Android APK, Windows EXE or Mac OSX App.\cite{coppercubefeatures} Actions and behaviours can be added to the game by JavaScript scripting, or by using predefined behaviours defined in CopperLicht such as `Fly in a Circle'.\cite{copperlichtbehaviours}

\subsubsection{Comparison of Solutions}
Table, descriptions

\subsection{Technologies Researched}
\subsubsection{Web Application Hosting}
\paragraph{Criteria.}
This project requires a powerful and scalable hardware solution, with automatic load balancing and ease of deployment being the most important requirements. The ability for the hosting solution to scale with the application and how many users there are will be essential in the future of the project.

\paragraph{Dedicated Server.}
The first option is to use a dedicated server without any distributed computing or virtualization. For this case I would use my own server which is provided by Hetzner; a Root Server EX40. As I would be using my own server, this option would be the most cost-effective, however the performance and scalability of the platform would not be suitable enough for the final release of the project.

It would be possible to make this option viable by manually setting up load balancing with nginx and caching tools such as memcached, however the workload to install and configure these systems correctly would be superfluous.\cite{nginxloadbalancing,memcached}

\paragraph{Amazon Elastic Compute Cloud.}
Amazon Elastic Compute Cloud (EC2), part of the Amazon Web Services (AWS) collection, is an \emph{Infrastructure as a Service}.\cite{awsec2} It is used by hundreds of large companies to host their web applications or even game servers. EC2 provides scalable virtual servers which can be made to fit any requirement by allowing the developer to install the required operating system and any type of application needed.

EC2 provides the flexibility, scalability and power needed for this project by automatically scaling up and down EC2 instances as needed.\cite{awsec2} Load balancing can be achieved using the Elastic Load Balancing service provided by Amazon.\cite{elasticloadbalancing} The only downside to using EC2 is that each EC2 instance will require setting up and deploying which could increase the workload significantly.

\paragraph{Amazon EC2 Container Service.}
Amazon EC2 Container Service (ECS) brings EC2 one step further by making deployment as simple as possible. Docker.io \emph{dockerfiles} are used to automatically create EC2 instances based on a specification created in a simple text file.\cite{awsecs} These instances can then be populated with apps and data specified in the dockerfile.\cite{dockerfile}

Using ECS would significantly speed up the time required to set up the necessary EC2 instances, especially if multiple instances are required; such as a load balancer, application and a database. ECS is currently in a preview state which must be applied for, so it may be unusable for this project unless the state of this changes.

\paragraph{Heroku.}
Heroku is a \emph{Platform as a Service} web application platform for deploying scalable web apps in the cloud. Heroku will automatically scale and manage applications deployed on the platform, making sure the application performs perfectly even under stress.\cite{heroku} Heroku has support for deploying applications built in many languages including Java, Node.js and Python.

Heroku itself has no storage systems available apart from their PostGRES database service. The lack of integrated file storage may complicate the implementation of user project storage. A cloud storage service such as Amazon S3 must be used instead.

\paragraph{Amazon Elastic Beanstalk.}
Amazon Elastic Beanstalk is a web application deployment service similar to Heroku. Elastic Beanstalk takes a web app and deploys it to an EC2 instance, automatically setting up and managing load balancing, scaling and any capacity needs.\cite{awselasticbeanstalk}

Using Elastic Beanstalk in my project would make deployment quick and painless, while still maintaining the same level of control that a standard EC2 instance has. The automatic load balancing process used with Elastic Beanstalk will automatically generate multiple instances of the application as needed so it can always be available no matter how many users are accessing it without any manual management.

\paragraph{Comparison.}
% TODO: Comparison table

\subsubsection{Web Application Frameworks}
\paragraph{Criteria.}
The web application framework should be as lightweight as possible, allowing the application to scale as needed. The framework should be flexible in use and support the Model-View-Controller pattern to be used in development. A strong template engine should be available to allow dynamic front-end pages to be built efficiently.

\paragraph{Node.js.}
Node.js is a platform for building applications using JavaScript as the main language. It uses Google's V8 JavaScript engine to increase the performance of JavaScript by compiling standard JavaScript to machine code.\cite{nodejs}

By default, Node.js isn't a web application framework, but can be made into a powerful one using one of many libraries available on the Node Package Manager.\cite{npmjs} An example of this would be using the lightweight Express web framework library and a template engine such as EJS or Jade.

\paragraph{Django.}
Django is a web application framework built on Python, which uses an MVC-like approach to designing websites.\cite{django} Django is designed to allow common web development tasks to be completed quickly and easily. It does this by providing APIs for Object-Relational Modelling to ease database usage, a powerful templating engine and automatic administration interface generation.\cite{djangooverview}

While Django makes complex web application development simple, it is bloated with features that may not be used at all in a lot of projects. For the purpose of creating this project, Object-Relational Modelling and automatic administration page generation may be entirely unused. 

\paragraph{Flask.}
Flask is lightweight Python-based web application microframework that comes only with a server and a templating engine. Flask is designed to be relatively simple at it's core, but becomes powerful through the use of modules that add extra functionality if needed.\cite{flask} The simplistic nature of Flask means it can be up and running relatively quick compared to other frameworks.

\subsubsection{Project Storage}
\paragraph{Criteria.}
User project storage is an extremely important part of this project. How the projects are stored will define how the application performs while saving projects, serving project files to players, and managing how users will collaborate on projects.

The project storage medium should be able to support some kind of version control, have good read/write performance, and should be scalable to some extent.

\paragraph{GitHub API.}
Storing user projects via the GitHub API without any server-side storage was the original proposed approach for this project.\cite{githubapi} Integrating the GitHub API into this project can allow the user to log into the application using their GitHub credentials via the GitHub OAuth system. \cite{githuboauth} This will provide an easier form of authentication than storing user details and passwords in a database which may not be as secure.

All storage can be performed directly through API requests to GitHub by submitting the user's files without any storage on the server.\cite{githubapicommit} This provides both version control and the cloud-based user storage this project requires, however access to the API is depended on heavily, which may be unavailable or slow at times.

There are a few problems with this approach. First is that it is very volatile; changes made by the user may be discarded if the user leaves the page without committing. Secondly, using the GitHub API does not do any merging of files, but instead overwrites files entirely, making collaboration hard for the users. This is discussed in greater detail in the Prototyping and Development area of this report (Section 6).

\paragraph{Amazon Elastic Block Storage.}
Amazon Elastic Block Storage (EBS) is a scalable solution to storage for use on Amazon EC2 instances. Performance on EBS is very high, as there are options for selecting between high/normal performance SSDs and standard hard drives. EBS volumes can be mounted directly to EC2 instances allowing standard file storage without any APIs.\cite{awsebs}

While EBS has no form of version control, local Git repositories could be used to manage version control. Since EBS can be mounted directly onto an EC2 instance, the command-line Git tool can be used to directly perform Git operations such as committing or even pushing to a remote server such as GitHub. Using GitHub with this option also means collaboration between users may be possible.

Implementing load balancing while using a mounted storage such as this may be problematic, since EBS volumes may only be mounted on a single EC2 instance. A workaround to this would be to use a single instance to write to the disk and then connect to that from the load balancing instances.

\paragraph{Amazon Simple Storage Service.}
Amazon Simple Storage Service (S3) is a storage system that is accessible through a REST-like API, which can be used with the AWS SDK which is available for several languages.\cite{awss3} S3 stores data as objects inside a container called a \emph{bucket}, where buckets can store any number of files up to 5GB each.

S3 is a powerful and cost-effective storage medium, especially suited to content delivery. It's backup and version control systems make it fairly suitable for this project.\cite{awss3} It may be hard to implement other systems like Git for user project storage and collaboration on S3 since buckets are only accessible via an API.

\paragraph{MongoDB GridFS.}
MongoDB GridFS is a high performance file system based on the MongoDB document database. It is designed to be used when documents that are larger than 16MB are to be stored in a MongoDB database, but can be used for small documents for consistency without any significant performance loss.\cite{gridfs}

Because GridFS is based on MongoDB, it is extremely suitable for horizontal scaling, but it does not support any atomic operations.\cite{gridfsatomic} The lack of atomic operations could make collaboration and version control hard to implement.

\subsubsection{Alternative Scripting Languages}
\paragraph{Criteria.}
Alternative browser-based scripting languages could be used to add typing and Object Oriented Programming to the game engine and user made games. While JavaScript has limited OOP functionality (Prototype chaining for inheritance), it is still a valid choice.

\paragraph{TypeScript.}
TypeScript is another alternative to JavaScript that was created by Microsoft to replace JavaScript. It provides a strong level of OOP functionality, scalability for large projects and optional type declarations on top of standard JavaScript syntax.\cite{typescript} In order to use existing JavaScript libraries with TypeScript, a header file is required to make the functions visible to TypeScript. TypeScript is transcompiled directly to JavaScript, and because of this it will often perform just as well as JavaScript does and doesn't require a virtual machine.

\paragraph{Dart.}
Dart is a compiled JavaScript alternative created by Google, with it's own virtual machine that supports OOP principals and static typing. Dart can also be transcompiled to JavaScript which allows dynamic loading of either the Dart file or the JavaScript file depending on what is supported by the browser.\cite{dart} Dart supports interaction with standard JavaScript libraries such as jQuery without needing to be modified in any way.

Dart runs in it's own Dart VM which boasts huge performance gains over JavaScript virtual machines, however the Dart VM is currently only supported on the \emph{Dartium} browser; a branch of Google Chrome. When using other browsers such as Firefox or the standard version of Chrome, Dart code transcompiled to JavaScript will often perform worse compared to standard JavaScript.\cite{dartperformance}

\subsubsection{JavaScript Libraries}

\paragraph{Rendering.}
Alternatives to Three.js were examined to determine their suitability to the project. The rendering library used should be suited to use in game development and have a flexible API.

SpiderGL is a WebGL wrapper that does very little abstraction to the API, making using WebGL slightly easier while still having low level objects such as vertex buffer objects.\cite{spidergl} In comparison to Three.js, Spider lacks a lot of features for rendering complex scenes, as well as being significantly harder to use.

SceneJS is a rendering library for JavaScript suited towards visualising highly accurate scenes with large amounts of detail similar to Computer-Aided Design (CAD). This library can be used to create and explore medical or engineering recreations, for example; the human body.

\paragraph{Physics.}
Existing research completed by Yogya and Kosalaa determined that out of several possible JavaScript physics engines including Bullet, Cannon and JibLib, ``Bullet is the best physics framework to be integrated into the WebGL-based game engine''.\cite{yogya2014comparison} Their conclusion is based on several factors, including performance, accuracy an compatibility with multiple browsers. 

\paragraph{Web Audio.}
Research into the use of audio in JavaScript has proven that the W3C Web Audio API is a sufficient option for this project's requirements. The Web Audio API supports the use of Cartesian coordinates to project sound effects using binaural positioning in a 3-Dimensional environment.\cite{webaudio} Binaural positioning is crucial to establishing the atmosphere in games such as first person shooters; where directional audio is necessary to create a sense of immersion.

The Web Audio API has support for real-time DSP sound filtering effects, which could be useful in the production of a game. DSP filters could be used to add distortion to ambient sounds based on events in the game such as an explosion.

Real-time audio can be examined in-detail with the Web Audio API using an audio analyser, which outputs a Fast Fourier Transform table (FFT). This table contains a set of volumes at specific frequencies. Games could be built around analysing these frequencies and performing specific actions, for example: triggering rendering effects when music becomes particularly intense.

\subsection{Other Relevant Research}
I have used WebGL in the past to create a simple rendering application. My experience with using WebGL was comparable to how it is mentioned in \emph{Programming 3D Applications in HTML5 and WebGL}\cite{parisi2014programming}. The application was designed to render objects using the pure WebGL API through JavaScript without any wrapping libraries. The result was an application of exactly 400 lines that was only capable of rendering a single multi-coloured box as seen in Figure \ref{fig:webgl} - this alone is evidence of how difficult WebGL can be to use.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{webgl}
	\caption{A textured cube rendered with WebGL}
	\label{fig:webgl}
\end{figure}

This experience using WebGL was the origin of my idea to simplify the method for developing games using WebGL. WebGL has great potential as the foundation for a powerful game engine, with it's strengths becoming evident while using OpenGL's shader language GLSL. Though it is powerful, the workload associated with using WebGL for even a small application was excessive.

A concept application was developed to examine the plausibility of using the GitHub API as a means for storing user projects without the use of storage on the server. This is discussed further in Prototyping and Development (Section 6).

\subsection{Resultant Findings / Requirements}
Based on the research completed, the following requirements have been determined, including optimal choices for technologies and architectures that will be utilised in this project.

\subsubsection{Background research.}
The background research has shown that web applications are becoming the standard, with almost every type of application now being able to be created on the web. Applications built on the web greatly simplify the process that users go through to access and utilise an application, and with cloud storage being utilized; the user doesn't need to store any files locally.

Game engines are being made easier to use and understand by patterns such as the Entity Component System. This system builds game objects by aggregating functionality from several smaller components, without any actual functionality being made specific to the object.

By combining the aspects of an Entity Component System into a game engine built on the web with a fully featured editor and cloud storage, inexperienced or hobbyist game developers will be able to easily create games and publish them without needing to invest a lot of time in installing software or learning APIs, so they can get straight to making their game.

\subsubsection{Existing Solutions.}
A comparison of the existing solutions to this problem has revealed ...

\subsubsection{Technologies.}
\paragraph{Web Application Hosting.}
An analysis and comparison of the examined application hosting solutions has determined that Amazon's Elastic Beanstalk service would be the optimal choice for hosting the web application, with Amazon EC2 Container Service being the second choice.

Elastic Beanstalk has several strengths over the other options, with the most pronounced being the automatic load balancing and interaction with EC2 instances. While other hosting solutions such as Heroku do have load balancing, they do not have the huge library of web services that can can be integrated with like AWS does.

The EC2 Container Service was a close second to Elastic Beanstalk, giving the most control over how the application would be deployed, but would require setting up the Amazon Elastic Load Balancer to interact with the containers manually.

\paragraph{Web Application Framework.}
The examined frameworks for developing web applications were fairly similar in functionality, flexibility and scalability. In my opinion, the optimal application framework to use would be Flask, as it requires minimal setup and can be extended using modules as needed. The other examined frameworks; Django and Node.js were too feature-heavy and required extra setup time respectively.

\paragraph{Project Storage.}
For user project storage, based on the findings the optimal project storage solution would either be Amazon S3 or Amazon Elastic Block Storage.

S3 provides an API for storing and retrieving files, with a version control mechanism. This could provide all of the functionality needed for project storage, however using s3 could make implementing collaboration difficult compared to using Git for version control and collaboration. Using S3 with the load balancing would be straightforward, as S3 can be accessed from multiple sources at once through the API.

Elastic Block Storage, which is a simple mounted volume which could be used with Git to provide a means of version control and collaboration. Using EBS with load balancing software is fairly challenging however, as the volume can only be mounted on a single application instance and load balancing will generate multiple instances of an application.

\paragraph{Alternative Scripting Language.}
Alternative scripting languages, Dart and TypeScript, were examined and compared to JavaScript. As the alternatives require compilation/transcompilation, standard JavaScript was decided as the optimal choice for use in this project. Implementing transcompilation in the web application is unnecessary as standard JavaScript can be used without major loss of functionality.

\paragraph{JavaScript Libraries.}
As a result of the research into several rendering libraries based on WebGL, Three.js was determined to be the most suitable for this project, as it has the features, flexibility, stability and power needed for use in game engines. The API it provides is abstracted significantly from the WebGL API to provide simple methods for doing normally complex tasks.

The Bullet physics engine and Web Audio API are highly suited for use in this project as explored in the research.

\subsection{Bibliography}
\bibliography{Report}{}
\bibliographystyle{unsrt}

\section{Analysis}

The project will be divided into three major components; the web application which will handle user authentication and project storage, the game engine which will provide the base framework for games and rendering, and the editor for building games with the engine.

\subsection{Web Application}
\paragraph{Hosting.}
The web application will be hosted using the Amazon Elastic Beanstalk Service, with additional EC2 Container System instances being used for EBS mounted storage and database hosting.

The load balancing system of Elastic Beanstalk will automatically duplicate the web application instance as needed when many users are accessing it, providing multiple running web applications that are chosen per-user on the fly. Since EBS volumes can only be mounted on a single instance and there may be many of these instances at one time, the EBS volume cannot be used directly from the web application. An intermediary instance will be created specifically for file access. 

This intermediary instance will run another Flask server designed only to access the EBS volume. An API will be created allowing the web application instances to perform actions such as store, retrieve and perform operations on the files stored on the volume. All web application instances created by Elastic Beanstalk will then communicate with this intermediary instance to access the volume. This instance will only be accessible internally, and will depend heavily on user authentication to provide security of the user files.

A simple MongoDB database instance will also be set up for use with the web application, which will provide a method to store and query a list of games that have been published by users of the application.

\paragraph{Framework.}
The web application framework that will be used is Flask, which provides a lightweight framework that is easy to work with. Modules for added functionality will be added to Flask as needed.

The web application will provide users with a view of their projects and allow them to create new projects, fork example or public projects, and delete projects as needed. When a user selects one of their projects they will be brought straight into the editor, where they can build their game. A list of publicly published games will be on the website, where unregistered users will be able to select a game and play it.

\paragraph{Project Storage.}
User project storage will be achieved using an Amazon EBS volume mounted on an EC2 container, and will store local git repositories for each project. This will allow the user to maintain a version management system for their project, and can be used to facilitate collaboration by pushing and pulling to a remote repository on GitHub.

Users will log into the application using their GitHub credentials, which are authenticated using the GitHub OAuth system. When the credentials are verified, an OAuth key is generated to be used for accessing the repository for the user's project.

Git operations will be performed on the local repository from Python via the Git interface for python \emph{gitpython}. This library allows asynchronous processing of git commands, which is a must when performing potentially long operations on the web.

To allow collaboration between users on the same repository, each collaborator of a repository will have their own git repository stored on the server. Collaborating through these repositories will be achieved by merging locally with the remote server on GitHub, then pushing the merge to the remote server.

\subsection{Game Engine}
\paragraph{Scripting language.}
Standard JavaScript will be used as the scripting language for both developing the game engine and creating games using the engine. This was chosen as the alternatives require compilation/transcompilation which would complicate the process of serving games to players.

\paragraph{Architecture.}
The game engine will be built in standard JavaScript using the Entity-Component-System pattern, with rendering powered by Three.js. Standard components including collision, lighting, camera, model and position will be created as a base for creating games in the engine. The creation of custom components through scripting will be possible, allowing users to add their own component-based functionality as needed.

The Bullet physics library and Web Audio API will be used to add physics and audio processing to the game engine, as they are highly suitable for use in game engines. Having physics and audio in the game engine is essential to being able to create interactive worlds.

\subsection{Game Editor}
The editor will be created using HTML5 and JavaScript, using Three.js for rendering components in the scene. Multiple views will be available on the editor UI, allowing the user to switch between free-look, top-down, and camera views to ease in the creation of the scene.

The editor will allow users to create their scenes using predefined entities such as cameras and lights, or by creating new entities with a list of components attached to them. Component properties for each entity will be editable by the user when selected. The user will be able to switch between multiple scenes for story progression.

Scene data will be stored in a serialized JSON format, so it can be stored in the user's project as a file and delivered easily to the player when the game is published.

A script editor will be built into the editor, allowing the user to modify scripts and other ascii files directly, instead of having to change page or re-upload scripts.

All of the Git functionality will be available through the editor interface, which will allow users to quickly sync up with collaborators. An interface will be created specifically to merge changes with the server before pushing, as this is required for collaboration via Git.

\section{Approach and Methodology}
Since the project is divided into three major components as discussed in section 3, the components will be developed in order of importance. The most important part of the application will be the web application, as all other components will rely on it heavily for user authentication, editing and creating games, and serving published games to the user.

When a usable implementation of the web application back-end is completed, development will move towards the game engine and editor, which will integrate heavily with the back-end. The game engine will be focused on first, with the game editor being developed last since it will depend on the other components extensively.

\subsection{Methodology.}
A Scrum-like software development methodology will be used for the duration of this project, along with elements from the Kanban method.

Scrum is a kind of Agile development methodology that is based on a series of iterative cycles of development called \emph{sprints}. These sprints will often begin with a brief planning session, can last from 1 to 4 weeks, then finish with a sprint retrospective to review how it went.

Scrum is usually a heavily team-based process, involving several roles such as `Scrum Master`, `Product Owner' and the Scrum team. Daily 15 minute team meetings are held to assess how the sprint is going, with each role and team member talking about what they did and what they plan to do. Since this project will be completed by a single person, I will be focusing on the iterative development, planning and review aspects of the Scrum methodology rather than the daily meetings and roles.

% http://www.mountaingoatsoftware.com/agile/scrum

Using an Agile methodology like Scrum means that most of the design of the application will be done as needed, rather than up front like the waterfall model. Design documents such as UML diagrams or entity-relationship diagrams will be left until they are necessary for the continuation of the development process, or if another part of the project depends on the design being completed.

A \emph{kanban board} will be used to manage tasks during each sprint. Trello will be used as the board by adding a list for each iteration in the development process. Cards will be added to these lists for each task, and labels will be used as kanban columns by using labels such as `Ready', `In Progress', and `Completed' as can be seen in Figure \ref{fig:kanban}. If cards are overdue, they can be moved to the next sprint list as a backlog, by dragging and dropping.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{kanban}
	\caption{Kanban-style task labels in Trello}
	\label{fig:kanban}
\end{figure}

Git will be used throughout the development process to provide version control and project management through branches. Branching will be used to manage the status of the project via stable and development branches. The Git repository will be hosted both locally and remotely on GitHub for a backup.

The methods for evaluation and testing have been documented in the Testing section of this report (Section 7).

\section{Design}
\subsection{Technical Architecture}
A technical architecture diagram was created to visualise the scope and structure of this project, as seen in Figure \ref{fig:architecture}. The design of this architecture focuses on the structure of the web application at a high level, looking at which technologies are implemented on specific platforms.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.72]{architecture}
	\caption{Technical Architecture for the Web Application}
	\label{fig:architecture}
\end{figure}

\subsubsection{Web Application.}
This area of the diagram visualises the technologies that make up the server-side of the application. There are three major parts to this; the web application, load balancing, and the project storage section, each of which are connected.

\paragraph{Web Application.}
The web application is deployed on the Amazon Elastic Beanstalk platform, with multiple instances being created on demand by the load balancing system. It is powered by the Flask web application framework which handles communication with the project storage container, and serves the application itself to the user's browser via the web.

\paragraph{Load Balancing.}
The load balancing is handled automatically by the Elastic Beanstalk platform. It has the capability to create multiple instances of the web application on demand, each of which will communicate with the project storage container to store, retrieve and manage user projects. Specific web application instances will be displayed to the user depending on the load at the time.

\paragraph{Project Storage.}
The project storage section shows how user created game projects will be stored in the system. The Flask application here provides an API to the web application, allowing multiple instances to access the Elastic Block Storage at once through the API. The Elastic Block Storage volume is mounted directly on the container to facilitate storage access.

Git operations are performed on the EBS volume from the Flask app; which allows version control between users. Direct access to GitHub is used when pushing to a remote location, which is used for backing up and collaboration with the GitHub API.

\subsubsection{Presentation.}
The presentation side of the diagram displays the aspects of the web application that will be visible to the user. Published games are served from the web to the user's browser, along with the game engine to run the game. The game editor will be accessible to logged in users, where they can edit and create games. The game editor requires the game engine for rendering the scene and play-testing.

\subsection{Other Design Documents}
As discussed in the Approach and Methodology section, the choice of using the Scrum methodology will allow me to produce design documents as needed rather than having all design completed before development begins as in the Waterfall model. Detailed design documents for each aspect of the application will be created as development begins in these areas.

\section{Prototyping and Development}


\section{Testing}
The Scrum methodology that will be used has a strong emphasis on integrated testing. Integration testing methods will be used during the development process, to validate that each task that was completed will work correctly in the project.

When a sprint is completed, regression testing will be used to find any bugs that may be present in the application. Regression tests will be documented for re-use in the next sprint, which will provide a few base tests that can be checked against the new iteration. Reusing regression tests will allow bugs to be found quicker, specifically when two sprints are in the same area of code.

% http://msdn.microsoft.com/en-us/library/aa292128%28v=vs.71%29.aspx
% http://msdn.microsoft.com/en-us/library/aa292167(v=vs.71).aspx

Stress testing will be completed to evaluate the performance and capacity of the web application back-end. This will provide insight into the amount of users the application will be able to handle at once, and if scalability will be an issue in the future of the application.

Towards the end of the project, evaluations will carried out to determine if each aspect of the project has met its requirements. Heuristic evaluations will be performed to identify usability problems with the user interface for the website and game editor.

User testing will also be performed at this stage, with feedback from the users that will determine if any features should be added or removed before final release. Groups of users with varying level of knowledge in the area will be involved, to get a good range of feedback about the project.

Users will be asked to fill in a survey of their experience after using the web application. Areas such as usability, functionality, stability, learning curve and performance, will all be evaluated using this process. The feedback from this process will provide necessary details in improving the project further before final release of the application.

\section{Issues and Risks}
% Using Git with OAuth tokens
% ECS Preview access
\section{Plan and Future Work}
% Prototype/Concept application: Try out local git with oauth tokens
% Use ssh keys instead - programmatically add one to github with API
% Continue work on application
\section{Conclusions}
\end{document}
