\chapter{Architecture \& Development}
This chapter will go into detail of the development stages of this project, discussing the various decisions, challenges and problems faced during the development of each individual component in the system, and how they were resolved.

\section{System Overview}
The system is separated into two individual development projects, \emph{the web server} which contains the website, game engine and editor, and \emph{the storage server}. These are both web based applications which host a HTTP server through the Python-based Flask microframework. An overview of the system is shown in Figure \ref{fig:overallarchitecture}, which labels the key components of the system in red.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.8]{overallarchitecture}
	\caption{Key components in the system}
	\label{fig:overallarchitecture}
\end{figure}

\paragraph{Architectural Patterns.}
The majority of the system follows the MVC (Model-View-Controller) software architectural pattern where possible. This pattern simplifies the development of complex systems by separating the data, display and logic sections into more managable subsystems - the model, view and controller respectively. The structure and architectural pattern of each individual component in this system will be described in-depth in Section \ref{section:systemcomponents}.

% ref MVC, simplifies

\section{Development Environment}
The environment used throughout development of the project consisted of the Sublime Text 3 editor running on the Fedora 19 operating system. For each individual Flask project (The web server and storage server) a virtual environment was set up using \textbf{virtualenv}. Use of virtualenv allowed Python 3.4.2 (separate to the version on Fedora 19) and the required Python libraries to be installed individually for each project.

For both projects, Flask and it's dependencies (itsdangerous, Jinja2, MarkupSafe and Werkzeug) were installed using \textbf{pip} in the virtualenv, along with the libraries specific to each project as seen below:

\begin{itemize}
	\item Web server:
	\begin{itemize}
		\item Flask-Compress
		\item PyMongo
	\end{itemize}
	\item Storage server:
	\begin{itemize}
		\item GitPython and dependencies (gitdb, smmap)
	\end{itemize}
\end{itemize}

The tools required to manage the Amazon Web Services were also installed in this environment, including the AWS CLI (Command Line Interface), and the Elastic Beanstalk CLI. These tools allow remote management of all AWS resources and quick deployment of applications to the Elastic Beanstalk platform.

The Git version control system was used to manage the project in this environment, with the project repository being hosted on GitHub as an external backup source. Originally, the two projects were in the same Git repository, however this proved to be unsuitable as rolling back changes on one project would be troublesome. The two projects were split into their own Git repositories using the \textbf{git subtree split} command, which maintained all commit history relevant to each project.

\section{System Components}
\label{section:systemcomponents}
	\subsection{Web Server}
	The web server is the core part of the system, where all user requests are handled. Everything the user does on the system goes through the web server, so it must be able to handle a lot of users. For this reason the lightweight `microframework' \emph{Flask} was chosen as the base of the server. %todo more

	\subsubsection{Architectural Pattern.}
	The Flask application created for the web server uses a software architectural pattern \emph{similar} to the MVC pattern. Flask lends itself well to the MVC pattern; as each page has it's own URL route (\textbf{Controller}) and template (\textbf{View}), with the route generally populating the template with data (\textbf{Model}). This can be seen visualised in Figure \ref{fig:flaskprocess} which demonstrates how a request is handled by Flask. A client sends a request to the route, the route then retrieves any requested data (Such as a list of published games), then it renders the template for that route with the data. The generated HTML from the template is sent back as the HTTP response.

	\begin{figure}[h]
		\centering
		\includegraphics[scale=0.8]{flaskprocess}
		\caption{The Flask request process}
		\label{fig:flaskprocess}
	\end{figure}

	\subsubsection{GitHub API Class}
	A \emph{GitHub} class was created to simplify communication with the GitHub API, by defining methods that would initiate the HTTP connection to GitHub and perform the desired API action, rather than having to set up a connection each time it was needed. Methods were created to handle OAuth operations like obtaining an access token and retrieving user information, as well as getting a list of the user's repositories or creating a new repository on GitHub.

	\subsubsection{Storage API Class}
	The \emph{Storage} class was also created to handle connections to the storage server through it's REST API. A method was created for nearly every route and request type on the storage server, which provided a very simple method of interacting with it from the web application. More information about the routes of the storage server are in section \ref{subsection:devstorageserver}.

	\subsubsection{Configuration}
	The web application loads it's configuration from the config.cfg file in the same directory. The configuration holds the required keys for the GitHub API such as the client ID, client secret and scopes, as well as the storage server's address and port, the MongoDB server address, and the expiry time for the access tokens. These configuration details are loaded in using Flask's built-in config loading methods, and allow the application to be easily reconfigured without having to change any internal code. This was especially useful for deployment, as the address of the storage server and MongoDB server are different once deployed to AWS.

	\subsubsection{Templates.}
	HTML templates are used to render the pages the server sends to the client. These are created using the Jinja2 templating language which is similar to embedding Python in HTML. Jinja2 has the feature of allowing templates to \emph{extend} or \emph{include} other templates, this means that they can be built upon eachother so very little HTML is repeated throughout the files. The Bootstrap library is used heavily here as well, which makes it easy to build visually pleasing templates.

	The template structure used for this website is built by extending a `base' template, which makes the creation of a consistently designed website easy. The base template creates the `html', `head' and `body' tags, links the stylesheets, adds a footer, then includes the `nav' template which has the top bar containing links to all of pages on the website. The rest of the body of the base template is defined as an empty `block'; which can be redefined by a template extending the base (Seen below).

	\begin{lstlisting}
{% block content %}{% endblock %}\end{lstlisting}

	The nav template uses conditionals in Jinja2 to programmatically change how the navigation bar is displayed to the user; it does this by accessing the session variable on the server to check if the user has logged in. When a user is logged in, they are shown the link to the dashboard, along with their avatar, name and a `log out' button. If a user isn't logged in then the `log in' button is shown. This can be seen below:

	\begin{lstlisting}
{% if 'access_token' in session %}
	<div class="userbox">
	<img src="{{session['user_info']['avatar_url']}}&amp;s=30" alt="">
	{{ session['user_info']['name'] }} 
	<a href="/logout">logout</a>
	</div>
{% else %}
	<form 
		action="https://github.com/login/oauth/authorize" method="get">
		<button type="submit" class="btn btn-default">
			Log in with GitHub
		</button>
		<input type="hidden" name="scope" value="{{config.GITHUB_SCOPES}}"/>
		<input type="hidden" name="client_id" value="{{config.GITHUB_CLIENT_ID}}"/>
	</form>
{% endif %}\end{lstlisting}

	\subsubsection{Routes}
	The development of this part of the system consisted of developing each URL that users could access on the website. These took the form as routes in the Flask application, designated with a URL containing variables (Denoted with <>), along with HTML templates that get rendered with data from the server (However not every route has a template).

	There is also a global `before\_request' method that is executed just before every request received, which sets up the connection to the MongoDB server, initialises the GitHub API class with the API keys, and set up the storage class that handles connections to the storage server. This simplified using these systems in the routes, as they could be accessed through the \textbf{g} (global) variable in Flask without needing to be set up each time.

	\subsubsection{/}
	The \textbf{/} route is the homepage of the website, which displays some information about Stratus and a short list of published games. This is achieved by getting the list of published games on Mongo, limited to 5 results and sorted by timestamp. The data retrieved is then rendered with the `index.html' template, which loops through the list of games and displays them in div tags with a `play' button linking to the \textbf{/game/<user>/<repo>} route.
	
	\subsubsection{/games}
	The \textbf{/games} route has a similar function to the \textbf{/} route. Instead of listing the most recently published 5 games, it shows an entire list of games published, which is sorted by user and repository.

	\subsubsection{/game/<user>/<repo>}
	The /game route is what users visit when they go to play a game on Stratus. Games that have been published can be accessed by anyone, however if they haven't been published they can only be accessed by the original owner. This is implemented by first checking the Mongo database to see if the game is published; if not then the user's session details are compared to the author of the game. If there are no session details or they don't match, the server will return a `403 Forbidden' page.

	When it has been determined that the user is allowed to play the game, the gamedata JSON and component scripts are retrieved from the storage server. These are then inserted into the `game.html' template, rendering them all in script tags. Component scripts are each given their own script tag by looping through the list of components, and the gamedata is given a script tag with the MIME type `application/json' to make sure it doesn't get executed as JavaScript.

	Originally this was going to be implemented using AJAX to load all files individually, but that was decided against to keep the response time as low as possible. Using AJAX would have also required the implementation of a loading screen to keep the user informed about what was going on.

	A separate template, `engine.html` is also inserted into the game template, which contains all the necessary script files for running a game. This includes the Three.js and Ammo.js libraries, along with all of the Game Engine scripts. This was separated from the game template to reuse it in the game editor.

	At the end of the game template, a small script initialises the game engine, which begins loading in the JSON object and building the scene.

	\subsubsection{/login}
	Authentication is performed using the GitHub OAuth API. This works by setting up an `application' in GitHub, and specifying certain `scopes', which give the application permissions related to controlling the user's settings or repositories. For the purpose of this application, the `user' and `repo' scopes were chosen, to allow the retrieval of user information and the creation of new repositories. After the application was set up, GitHub provided a \textbf{Client ID} and \textbf{Client Secret}; these are used to tell the OAuth system what application the client is using.

	To create the login system, a button is added to the website which redirects the user to the GitHub OAuth page, with the client ID and scope sent with them. This URL takes a form such as:

	\begin{lstlisting}
	https://github.com/login/oauth/authorize?scope=user,repo&client_id=170c030cc1ef6a518a8e\end{lstlisting}

	Upon authorising the application, GitHub will redirect the user back to the `Authorization callback URL' (the \textbf{/login} route) specified in the application configuration, providing a \emph{code} in the URL which can be used to get an \textbf{access token} for the user.

	\begin{lstlisting}
	/login?code=a9888d90ed2ac97cee5e\end{lstlisting}

	When a user is redirected to the \textbf{/login} route with a code from GitHub, the route uses the code to get the user's access token to complete the GitHub OAuth process. This is done by sending the code, the client ID and the client secret to the GitHub API, using the class described above. The URL of this request takes the form of:

	\begin{lstlisting}
	https://github.com/login/oauth/access_token?code=a9888d90ed2ac97cee5e&client_id=170c030cc1ef6a518a8e&client_secret=3oeqft9w9zd536m0oxar\end{lstlisting}

	The GitHub API then responds in a JSON format, providing the access token which allows the web application to perform actions on the user's GitHub account. The user's details are retrieved using this access token, which are then stored with the access token in the user's session in Flask, which allows them to be held on to for the duration of the user's stay on the website without any external storage. 

	After the user's details have been retrieved successfully, the \textbf{/login} route redirects them to the \textbf{/dashboard} route, where they can manage their list of games. The session can now be used to determine if a user is logged in by checking if the access token part of the session exists and is valid.

	\subsubsection{/logout}
	When a user wishes to log out of the system, the /logout route clears the session holding their details, then redirects them back to the homepage. Since the session no longer has their details in it, they will be unable to use any of the features that require them until they log back in. The GitHub OAuth system will remember that the user has authenticated using this application before, so if they choose to log in again, they won't need to authorize the application, and will be logged in straight away.

	\subsubsection{/dashboard}
	The dashboard is where a list of the logged in user's projects are displayed, along with their respective Git status, and whether or not they are published. The dashboard route pulls all the information about the user's repositories on the system from the storage server, using the restful API. Then, for each repository it obtains the git status; checking if there are any uncommitted changes in the repository. The list of published games for the current user is also obtained from the MongoDB database. All of this information is pushed into the `dashboard.html' template, which is rendered and displayed to the user. If the \textbf{/dashboard} route is accessed without a user being logged in, a 403 Forbidden error is shown, however this normally shouldn't occur as the dashboard link is hidden for guests.

	There are a number of actions available to the user on the dashboard, related to the management of their game projects on the system. Each of these actions have their own route on the web application prefixed with /dashboard/ which requires a user to be logged in, and redirects back to the dashboard with a message (Action completed, error occured) when completed. These actions are detailed below:

	\paragraph{publish/<repo>.}
	The publish action toggles whether or not the specified repository of the current user is published on the system. It does this by searching the database to see if it currently is published; if so it deletes the entry in the database. If it isn't published, then it will add an entry specifying the current time as the publishing date.

	There are two problems with this, the first being if the user has another dashboard tab open that hasn't been refreshed, they may end up attempting to publish a game that has already been published in the other tab, causing it to be unpublished. The second problem is that when the game is unpublished and re-published successively the timestamp will update, which could be used to game the system and keep that user's game at the top of the `latest' list.

	\paragraph{init/<repo>.}
	The init action creates a new repository for a game on both the storage server and the GitHub account of the user. A popup on the dashboard asks what the user would like to call their repo, then redirects them to this route. The repository is created by first checking if there is a repository with this name, and aborting the process with a message to the user if that is the case. The route then uses the storage API to create the new repository on the storage server, passing in the user's GitHub access token which is used to complete any git push or pull actions later on. The remote repository on GitHub is created through the GitHub API which is necessary to allow the user to push their changes to GitHub. The new repository is initialised with an empty `gamedata.json' file to signify that it is a Stratus game.

	Any errors that occur during this process will cause the route to redirect back to the dashboard with an error message, explaining what happened to the user. If the process completed successfully, the user is shown a `success' message on the dashboard.

	\paragraph{delete/<repo>.}
	The delete action will delete the specified repository and all changes from the storage server, but not the remote GitHub repo. This is performed through the storage API and discards any changes that weren't pushed to GitHub, which could be devastating to a user if done by accident. The dashboard makes this slightly safer by displaying a popup to the user asking if they really want to delete it before sending them to this route. Any repo that is currently published when being deleted will have their entry removed from the MongoDB \emph{published} collection.

	\paragraph{commit/<repo>.}
	The commit action will create a new commit of any new changes in the specified repository. The dashboard provides a pop-up textarea for inputting the commit message, which then POSTs the message to the repository specific route when the user submits it. 

	The commit is made through the storage API, by first retrieving the status of the repository; which contains a list of modified, deleted or untracked files. This list is sent along with the commit message to the storage server, which performs the \textbf{git add} and \textbf{git remove} operations then creates the commit with the message.

	One problem that was encountered while developing this route was that any commit that was pushed to GitHub didn't show the correct author. This was resolved by sending along the user's name and email address from the session to the storage server, which then added those to the commit as the `committer'.

	\paragraph{push/<repo>.}
	The push route instructs the storage server to push any commits that have been made to the GitHub remote server. There is a possibility for the user to encounter an error here if they have been changing the repository outside of Stratus; that is if the remote server (GitHub) has changes that are ahead of the repository on the storage server. If a user attempts to push when this is the case, GitHub will reject the push.

	In the event that this happens, the user will receive a message suggesting that they attempt to pull the remote changes before pushing. This will most likely resolve the issue, as the changes from the remote and local changes will be merged automatically on the storage server. The changes can then be pushed as normal.

	\paragraph{pull/<repo>.}
	The pull route is used to retrieve any changes from the remote git server, GitHub. This is completed by contacting the storage server through the API and telling it to perform the git pull operation on the specified repository. As above, there are some issues that may be run into with this, specifically related to \textbf{merge conflicts}.

	Merge conflicts occur when remote changes are unable to be merged automatically with the local changes of a repo during a pull. In this situation, the file(s) that have conflicting data must be manually patched, as the lines will be replaced with \textbf{both} sets of conflicting data. An example of what this looks like is below:

	\begin{lstlisting}
"scale": {
        "type": "vector",
        "parameters": [
<<<<<<< HEAD
                110.57,
                106.95,
                16.31
=======
                1000,
                800,
                1
>>>>>>> 96a40b322727f0c034e26a438461d53962bdec7e
        ]
}\end{lstlisting}

	When this is the case, it's impossible to create a commit until this has been resolved; as it will always fail. This can also cause the editor and game routes to become dysfunctional if it happens on the gamedata.json file, as it will no longer be valid JSON.

	Currently there is no implemented method to resolve merge conflicts on Stratus, however this is one of the first features that will be added if the project is continued, as it will greatly help with the collaboration of team members working on a game together through Git.

	\paragraph{clone/<repo>.}
	The clone route performs an action similar to the \textbf{git clone} command. It \emph{clones} the specified remote repository from GitHub, along with all of it's contents, and stores them on the storage server. This is actually done as a two step process, where the local repository is initialised with the same details as the remote repository, then it is \emph{pulled} to retrieve all of the contents from the remote. A list of repositories on GitHub is retrieved using the GitHub API and displayed on the dashboard, which allows the user to select from a list rather than having to input the repository name.
	
	\subsubsection{/editor/<repo>}
	The editor route is where users will be able to modify their games. Users may click on the `edit' button for one of their games in the dashboard, which will bring them to the editor for their selected game. In a similar method to the \textbf{/game/<user>/<repo>} route, all of the game files are retrieved from the storage server and then inserted into the `editor.html' template, along with the list of files in the repository. The template itself loads all of the necessary files for the editor, such as the numerous `view' script files, and the templates for those views. This is discussed further in section \ref{subsection:gameeditor}.

	Since the editor is designed to modify files for the user, it needed a method of storing and retrieving the files on the storage server. This was provided by the \textbf{/editor/<repo>/<file>} route. This route accepts GET, POST and DELETE requests in a similar manner to the RESTful API on the storage server, in order to update files such as the gamedata.json file, or custom component scripts. This was needed as there is no way for the client to communicate with the storage server directly.

	\subsection{Storage Server}
	\label{subsection:devstorageserver}

	The storage server is a REST API that provides a central access point for each web server instance's storage needs. It was required to be separated from the web server so that the stored data would be persistent accross each instance of the web server that is created. A REST (Representational State Transfer) API was chosen for this part of the server as it provides a very simple interface for the management of resources; in this case it is for managing files on the filesystem. 

	The storage API is developed using Flask and provides several routes (URLs) that are prefixed with a user and repository for specifying the game to work on. These routes usually take the form of `/<user>/<repo>/<action>/<...>', with a good example being `/dcrn/stratus-pool/file/gamedata.json'. Each route supports several HTTP request types, including \textbf{GET}, \textbf{POST}, \textbf{PUT} and \textbf{DELETE}; with each request type having an action to perform on the resource requested:
	\\
	~\\
	GET requests will \textbf{retrieve} a resource, or the status of a resource.\\
	POST requests will \textbf{create} a resource or perform an action.\\
	PUT requests will \textbf{update} a resource.\\
	DELETE requests will \textbf{delete} a resource.\\

	\subsubsection{Architectural Pattern.}
	The software pattern used for the storage server is similar to the MVC system generally used in Flask, however MVC is more suited towards applications that have a user interface; a `view'. In this case the JSON output by the RESTful API could be considered the view, with the controller being routes and the model being the file structures.

	\subsubsection{GitPython}
	The GitPython library was included in this project to provide a method of performing git operations on the local files via Python. GitPython is a wrapper around the \textbf{git} command, which provides an interface that is familiar to executing git commands manually. The usage of this library is seen below in the routes related to performing Git operations.

	% todo ref gitpython, ref api?

	\subsubsection{Routes}
	The following sections detail the API routes created for the storage server, categorised by the request types available on that route.

	\subsubsection{GET - Retrieve information}
	
	\paragraph{/<user>.}
	This route retrieves the list of repositories on the storage server for the specified user; obtained by searching the user's directory with Python's built-in \textbf{os.listdirs} function. For each directory found, it checks if there is a git repository initialised; by using the GitPython library's git.Repo method. The git.Repo method will throw an InvalidGitRepositoryError exception if the directory has no git repository in it.

	Then, for each repository, the number of \emph{unpushed commits} is calculated to provide the dashboard with information about the remote git repository. This is done by calling repo.iter\_commits, a method similar to the \textbf{git rev-parse} command. Iter\_commits is used to retrieve the symmetric difference between the last pulled remote version and the latest commit (the HEAD) by specifying the git rev-parse arguments `remote/branch..' which is a shorthand version of `remote/branch..HEAD'. This only works if there \textbf{is} a remote version at all, which is troublesome in the case of newly created repositories. Because of this, the remote reference is checked to see if it exists, and if it doesn't then the number of commits ahead of the remote is set to 1.

	The output of this route is returned as a JSON object listing the repository names as the keys and their values being the number of commits ahead of the remote (Seen below). In the event of an error, an empty JSON object is returned and the appropriate status code is returned; such as 404 for a user that doesn't exist.

	\begin{lstlisting}
{
	"stratus-pool": 0,
	"test-repo": 0,
	"test-repo2": 1
}\end{lstlisting}

	\paragraph{/<user>/<repo>/status.}
	The status route retrieves the status of a git repository, similar to the \textbf{git status} command, returning a list of added, deleted, modified, renamed and untracked files in the specified repository. The GitPython library is used to obtain the most recent commit (if any), and compares it to the working version of the repository, calculating the `diffs' (differences) between them. The diffs are then iterated, categorising the changes by type (modified, deleted, ..) and storing the filenames for that diff. The results of this are then sent back in a JSON format along with a list of any untracked files in the repository. In the case that there is no previous commit to compare to, only the list of untracked files in the repository is used.

	\paragraph{/<user>/<repo>/tree/<path>.}
	The tree route uses the built-in Python function \textbf{os.walk} to get the directory tree of all files in the specified repository and path. This is used in the editor when listing out the custom components users have made. The `path' specified at the end of the route is optional, and defaults to the root of the repository. The result of this is returned in a JSON format, which structures directories as an \textbf{object} and files as the value \textbf{true} (Seen below).

	\begin{lstlisting}
{
	"components": {
		"cuecontroller.js": true
	},
	"gamedata.json": true
}\end{lstlisting}
	
	\subsubsection{POST - Perform actions}

	\paragraph{/<user>/<repo>/push/<remote>.}
	The push route performs the \textbf{git push} action on the repository, with the specified remote. This is equivalent to running `git push <remote> master' in a terminal. This is done by finding the remote on the repo object (if it exists), then running the GitPython method \textbf{remote.push}, specifying the a reference to the latest commit in the repo (repo.head.reference). If the push command is rejected by the remote for some reason, the output from this route will be a 409 Conflict status code, along with an empty JSON object. If the push is completed successfully, a 200 OK status code is returned.

	\paragraph{/<user>/<repo>/pull/<remote>.}
	The pull route performs a \textbf{git pull} action using GitPython. This is done by first fetching any changes from the remote using the remote.fetch method, which is similar to the \textbf{git fetch} action, then replacing the local HEAD reference with the remote HEAD reference using the remote.pull method. When the pull action is completed, the route returns an empty JSON object and the 200 OK status code. If fetching or pulling the changes causes any errors, this will return a 409 Conflict status code.

	\paragraph{/<user>/<repo>/commit.}
	This route is used to create a commit on the storage server, and is similar to using the \textbf{git add}, \textbf{git remove} and \textbf{git commit} commands all together. The route requires that some JSON is sent along with the POST request, which should contain a list of files to be added and removed, and a commit message.

	The list of files to be added is iterated and added to the repository's index (Also referred to as the staging area), which is a list of files that will be in the next commit. Any files that are in the removal list are removed from the index. When this is completed, a new commit is created, specifying the message passed in with the JSON. This will automatically push the new commit to the HEAD reference.

	An issue that was encountered here was that when the commits were pushed to GitHub, it showed them as being made by `root', instead of the correct author. This was resolved by sending the author details (full name, email address) over from the web application, and setting them as the author and committer on the commit.
	
	\subsubsection{GET, PUT, POST \& DELETE - Control resources}
	
	\paragraph{/<user>/<repo>.}
	This route is used to create, update, delete and get information about a repository. The action performed depends on the request type. Each of these requests will determine if the repository exists and return the appropriate status code with a JSON object.

	To create a repository, the POST request method is used. The repository is initialised using the Repo.init method of the GitPython library, which creates a repository in the specified folder. Details about the remote Git server can be sent with the POST request as a JSON object, detailing the remote name and URL to be used for the remote. This was a crucial part of the implementation of Git into the system, as the remote needs to specify the username and their access token in the URL or the push and pull actions won't function.  An example remote URL would be:

	\begin{lstlisting}
https://username:accesstoken@github.com/username/repository.git\end{lstlisting}

	Updating a repository is done through the PUT request method, which allows the remotes specified for the repository to be changed to the values specified in the JSON object sent with the request.

	A DELETE request will delete the repository, including any changes the user hadn't pushed to the remote server.

	The GET request will return a list of the remotes for the repository, and the hex code of the HEAD commit. This is returned as a JSON object and with the 200 status code if the repository exists.

	\paragraph{/<user>/<repo>/file/<path>.}
	This route is used to get, create, update and delete files in the specified repository.

	The GET request method will return the contents of the requested file in a JSON object, specifying the `data' as the content of the file. If the file doesn't exist then a 404 status code will be returned.

	The POST request will create the file, and expects a JSON object to be passed along with the request that contains a `data' value to populate the file with. If the file already exists, the route will abort and return a 409 conflict status code.

	A PUT request will update a file's contents, provided it exists and the request contains a JSON object with a `data' value in it. If the file doesn't exist then a 404 status code is returned.

	A DELETE request deletes the specified file if it exists, returning a 200 OK status code if completed successfully.

	\subsection{Game Engine}
	The game engine is the code that runs all of the created games on Stratus. It is built in JavaScript, using the Three.js and Ammo.js libraries to create a game engine capable of complex graphics such as lights and shadows, along with integrated physics.

	\subsubsection{Architectural Pattern}
	The Game engine follows the Entity-Component-System architectural pattern as discussed in the design section. It works by having each game object be a container of several components, each with individual properties. This simplifies the method of creating complex game objects down to adding several small components together.

	\subsubsection{Game object}
	For the implementation of the ECS pattern, a `Game' object was created which acts as the `System' part of the ECS pattern. The Game object is responsible for loading the game data (Scenes, entities and components) from the serialized JSON form, which it then starts running and updating. 

	When the Game is initialised, it first creates a Three.js \textbf{renderer}, which it uses to render the currently active scene. The game can then be started, which begins running the main \textbf{update} function. The update function is responsible for rendering and updating the scene every frame, as well as sending the deltatime to each scene which lets it deal with varying framerates. The HTML5 requestAnimationFrame function is used to specify that the update function should run on the next frame draw event, and must be called every frame for it to continue updating.

	The Game object also has several methods available to control the renderer, such as setting the currently active scene and camera, changing various shadow rendering properties, and setting the background colour. A `pointer lock` setting was also added which uses the HTML5 Pointer Lock API to lock the player's pointer, which is useful when applied with the Fly Controller or FPS controller, as the mouse will be hidden and lock to the center of the screen; allowing continuous looking around without hitting the border of the screen.

	% todo ref pointerlock

	\subsubsection{Scene}
	The Scene class is, simply put, a wrapper around the Three.js Scene class, combined with the Ammo.js DiscreteDynamicsWorld class. These objects together allow the Scene class to manage any renderable objects and physics objects that are in the scene.

	This class holds a list of entities that it contains, and upon adding an entity it checks to see if any of the entity's components contain a Three.js object or an Ammo.js object. These are found on the component under the properties `threeobj' and `ammoobj'. If a threeobj is found, it is added to the Three.js scene object so it can be rendered, and any ammoobj objects are added into the dynamics world.

	A game can have several scenes in it, but only one currently rendering and updating at a time. For this reason an \emph{activate} method was added, which makes that scene the active scene on the Game. When a scene is active, it receives an \emph{update} call every frame, which allows it to update the dynamics world object along with all of the entities in the scene. When a scene is activated, it will also activate a camera in the scene, which is necessary for objects in the scene to be visible when rendering.

	\subsubsection{Entity}
	The Entity class is the base for creating a complex object in the world. It starts as an empty `components' container that can be populated with various components to give it functionality such as a shape and a physics collision box. 

	The entity class allows components to be added or removed using the \textbf{add} and \textbf{remove} methods, which trigger an event on the child components, \textbf{onComponentAdded} and \textbf{onComponentRemoved}. These events are used to tell the component about it's siblings incase they have any interactions. When the scene containing the entity is \textbf{updated}, the entity object will then update all of it's children components.

	\subsubsection{Component}
	Components are what add functionality to the game, including the ability to render shapes and add collision to those shapes. Each component is created by defining a new class that can then be registered as a component using the global \textbf{Components} object. The simplest form of this would be:

	\begin{lstlisting}[language=Java]
	ExampleComponent = function(options) {};
	ExampleComponent.prototype.update = function(deltatime) {};

	Components.register('example', ExampleComponent);\end{lstlisting}

	When the new component has been registered it can then be created using Components.create('example'). The Components.register function can also be used to define properties for the component, which will then show them as changable properties in the game editor interface. Properties are given a name, type and a default value. A good example of this is the properties for the `mesh' component:

	\begin{lstlisting}[language=Java]
Components.register('mesh', MeshComponent, {
	shape: {type: ['box', 'sphere', 'cylinder'], default: 'box'},
	castShadow: {type: 'bool', default: false},
	receiveShadow: {type: 'bool', default: false},
	materialType: {type: ['phong', 'lambert', 'basic'], default: 'phong'},
	materialColour: {type: 'colour', default: 0xFFFFFF}
});\end{lstlisting}

	This shows the properties for shape, shadows and materials available on the \textbf{mesh} component. The type of property set on the shape and materialType are a list of possible values, which means the properties UI should show a selection box. These properties can now be changed in the game editor, and get stored in the gamedata JSON file.

	When a component is created using Components.create, properties can be passed in to initialise the component with some values, as done in the Game object's loading stage. Any properties that are missing will use the previously set default properties (if any), which are then passed to the constructor of the component as the `options' variable.

	Several optional methods can be implemented on a component, which are used to respond to certain events in the game engine. The previously discussed onComponentAdded and onComponentRemoved can be added to listen for new components being added to the parent entity, or if the component itself was added to a new entity. A method called applyOptions can also be implemented which allows the editor to update the entity displayed in the editor with new properties.

	\subsubsection{Predefined components}
	There are several predefined components supplied with the game engine that make it easier for users creating games. Without these components, making a game would be like creating the entire game engine from scratch. Each component is discussed in detail below:

	\paragraph{Transform.}
	The transform component handles the positioning, rotation and scale of any entity that it's attached to. It does this by storing a Three.js `Object3D' object, which contains it's own position vector, rotation quaternion and scale vector. Methods for setting and getting these properties are exposed, such as getPosition and setPosition. 

	The transform component also has the ability to `subscribe' to another component. This is a very useful ability, as it changes all getter and setter methods to operate on the desired component instead of the local values the transform holds. This is currently used for any entities with a `physics' component; since the position and angle should be based on that instead of staying fixed.

	\paragraph{Mesh.}
	The mesh component is a wrapper around the creation of Three.js mesh objects. It starts with a blank mesh object, then adds a geometry object specified by the properties (e.g. `box', `sphere' or `cylinder'). Material settings can be changed such as the type (Phong, lambert, basic) and colour, as well as if the mesh should receive and cash shadows.

	In order for the mesh to follow any physics objects on the entity it is attached to, the Three.js mesh object's position, rotation and scale are copied from the transform component (If there is one) on the same entity whenever it updates.

	\paragraph{Light.}
	The light component is a wrapper around the Three.js \textbf{AmbientLight}, \textbf{SpotLight}, \textbf{DirectionalLight} and \textbf{PointLight} classes. It dynamically creates one of those classes depending on the `type' property on the light. Making the light component work when removing or changing type was a huge problem that was encountered. This was because of the way Three.js works internally; any light that is created stays in the scene forever even if removed, and any new light that is created won't cast shadows on existing objects.

	This was remedied by following the author's guidelines on updating Three.js objects realtime. Any light that is removed from the scene is first set to stop casting shadows and the intensity of the light is set to 0. Any newly created light triggers the scene to search for all material objects and set `needsUpdate = true' on them.

	% todo ref https://github.com/mrdoob/three.js/wiki/Updates

	\paragraph{Physics.}
	The physics component is an interface for the Ammo.js rigid body object, btRigidBody. This represents a collision object in the world, which can collide with any other collision objects that have been added to the scene. Methods that act upon the rigid body object are exposed as methods on the component, such as changing the mass of the object or applying forces to it with \textbf{setMass} and \textbf{applyCentralForce} respectively.

	When the physics component is added to an entity (or a transform component is added to the physics component's parent entity), it will automatically set the transform component to subscribe to the physics component. This means that any other components on the entity will follow the physics object's position and rotation.

	\paragraph{Camera.}
	The camera component wraps the Three.js \textbf{PerspectiveCamera} class, which represents a position, angle and perspective matrix in the scene. The camera object is used during rendering and can be `activated' like a scene to make it the active camera. The field of view angle, near and far plane values can be set on this component to change how the player will view the world.

	\paragraph{Fly Controller.}
	A controller component is a component that is designed to take input from events and allow the player to control the parent entity in a certain way. This idea has been seen in Unity as the `First Person Shooter' controller, among others.

	The fly controller component is one that takes input from the player's mouse and keyboard (Using JavaScript document events) and allows them to \emph{fly} around the scene. This is a pretty useful component as it can be quickly added onto an entity with a camera to explore the scene. The keydown, keyup and mousemove events are used to allow the user to move around using the W, A, S and D keys, while moving their mouse to look around.

	\paragraph{FPS Controller.}
	The FPS controller component is another controller, that is similar to the `First Person Shooter' controller implemented in Unity. This controller has a physics component built into it that allows the player to walk around the scene, pushing  objects with their body. User input is translated into forces on the physics object, instead of setting the position like the fly controller does.

	\subsection{Game Editor}
	\label{subsection:gameeditor}
	The Game Editor is a key part of the system, which utilises the game engine and storage server heavily to provide the user with a positive experience in creating their games. This is where the gamedata JSON structure is created and modified, by allowing the user to create new scenes, entities, components and modify properties on those components. New scripts can be created through the editor's built-in script editor provided by the Ace editor JavaScript library.

	The editor also makes heavy use of a templating engine called Handlebars.js, which allows template HTML files to be populated with data from JavaScript, which are then inserted into the page via jQuery. This was necessary as the editor has several small UI elements that are often repeated or reconstructed (Such as the properties view). The majority of the editor UI uses components from Bootstrap to make it appealing to the user.
	
	\subsubsection{Architectural Pattern}
	The architectural pattern used in the construction of this component in the system is heavily influenced by the MVC pattern, as well as some JavaScript frameworks including Backbone.js and soma.js. The editor consists of a single `Editor' object, which could be considered the controller. Several small view classes were constructed for each element of the editor's interface, with some views even containing other views (Similar to Backbone.js).

	Views in the editor follow a trend of having a `render' method on them, which returns an element. The majority of the views have a related Handlebars.js template, which will be populated with data and returned from the render method, while some just have a `div' or `ul' tag.

	\subsubsection{Views}
	There are several views in the editor, most of which are simply wrappers around a Handlebars.js template, inserting the data then rendering it. The essential views in the editor including the scene explorer, properties and the scene view are described below:

	\paragraph{Explorer.}
	The explorer view consists of a tab view, which has a tab item for the scenes and scripts in the game. The scenes tab is where the gamedata JSON is visualised, showing the tree of scenes, entities and components currently in the game. The scripts tab shows all of the component scripts in the repository (in the /components directory).

	The scenes tab consists of a tree of ExplorerSceneViews (which is a `ul' HTML tag), containing several ExplorerSceneItemViews (a `li' tag) - each of which can have their own child ExplorerSceneView. This represents the structure of the gamedata JSON; where each scene has a number of child entities, and each child entity can have a number of child components. Events on these items such as clicking on the `duplicate' button on an entity will be sent to the Editor object, which will perform the operation on the gamedata JSON and update the views accordingly. Each item in the tree can be selected, updating the properties or scene view.

	The scripts tab uses views fairly similar to the scenes tab, but doesn't need to be in the tree structure. The scripts tab lists all custom component scripts in the ExplorerScriptsView with ExplorerScriptsItemViews. These item views render the related Handlebars.js template to construct the `li' tag with buttons that perform actions such as editing, duplicating or deleting scripts.

	\paragraph{Properties.}
	The properties view is what shows the component properties for the currently selected entity in the explorer. When the user selects an entity in the explorer, the Editor object receives the event and gets the specific JSON related to that entity along with the properties defined for each component on the entity. This data is sent to the properties view which is then re-rendered; updating the display with inputs for each type of property, categorised by component.

	The properties view displays this by rendering the view's template using the data passed in directly. The template is able to loop through each component and each property on that component, displaying the related input for that type of property. For complex types such as a vector, colour or quaternion, sliders are added for each axis (x, y, z or r, g, b).

	Unfortunately the Handlebars.js library isn't able to check if two values are equal, or if an object is a list. This was crucial to implementing the properties where a value is chosen from a list, such as the mesh component's shape. Two operators were added to Handlebars.js by registering `helpers' through the Handlebars object. The operators `isArray' and `eq' were added, which was fairly simple but solved all issues related to rendering the properties.

	After the properties view is rendered from the template, event handlers are added to the inputs through jQuery. The event handlers are set up to receive any inputs, convert them back to the correct property type (e.g. vector, quaternion, colour), then the event is sent back to the Editor object where it uses the new property value to update the gamedata JSON and the scene view.

	\paragraph{Scene View.}
	The scene view is where the currently selected scene is rendered, providing visual feedback to the user. A Three.js renderer is created in the same way the Game Engine works, which gets returned from the render method on the scene view. When the scene view is initialised with the gamedata from the Editor object, it is loaded using the Game.load method in the game engine, which returns a list of game engine scene objects. These are rendered in the same way was the Game, but using the scene view's renderer, and a separate camera created for the scene view.

	Events were added to the scene view element to provide the user with the ability to move around the scene while creating it. These consisted of the keydown, keyup, mouseup, mousedown and mousemove events. These events allow the user to move the scene view's camera around the scene using W, A, S, D and change perspective by moving the mouse. Instead of having this active all the time, it was changed to only be active while the user is clicking on the scene; this makes it a bit easier to use the editor without accidentally looking around the scene.

	A visual indicator was added to the scene view to indicate what entity the user had selected in the explorer. This consisted of a wireframe box surrounding the object, but this evolved into the selection object (described below) to provide the user with a more intuitive method of moving entities around a scene.

	\paragraph{Selection Object.}
	The selection object is a Three.js object that consists of a wireframe box to outline the selected object, and three `handles'; one for each axis. It was created to allow the user to click and drag objects around the scene rather than having to change the position values in the properties editor.

	This is achieved by using the Three.js raycaster object to check if the user's click event has `hit' any of the handles on the selection object; if they have, then whenever the mouse is moved the object will follow their mouse.

	Two planes are created, on the x and y axis. When a user has clicked on the handle for the x axis and begins moving their mouse, a new raycast is performed to the y axis plane, which then uses the `hit' position to calculate how much to move the object by. This uses the dot product of the hit point relative to the object and the axis' unit vector. The dot product gives back a distance to the `handle', which is added to the position of the object to move it towards the user's mouse cursor.

	The same is performed on the y axis handle, which raycasts to the x axis plane, and the z axis handle which raycasts to both the x and y axis planes; which is necessary as the user could be viewing the object from a point that is perpendicular to one of the planes.

	The updated position is sent to the global Editor object, which updates the gamedata for that object and re-renders the properties view to update the position sliders.
	
	\subsubsection{Script editor}
	The script editor was implemented using the c9 Ace editor, a javascript library which provides a rich script editor to webpages. The Ace editor has the ability to choose a `mode', such as `JavaScript', which provides rich syntax highlighting along with pointing out any syntax errors that occur when writing a custom component.

	Automatic saving was added to the script editor, so whenever the `change' event is triggered a timer will start at four seconds. If any change events happen again during those four seconds, it will reset the timer. At the end of the timer's duration, the Editor will be told to save that file with the contents of the script editor. It will also save the script immediately if the tab holding the script editor is closed.

	\subsubsection{Autosaving}
	Automatic saving was added to the Editor, which is triggered whenever the `modified' method is called. This again starts a timer similar to the script editor's functionality, POSTing the gamedata JSON to the web server using AJAX in the background. The modified method is called whenever any of the editor changes the gamedata JSON, such as adding a new scene or changing properties of a component on an entity.

	In the event that the user closes their editor tab, or even changes to a different tab in their browser, the editor will save immediately. This was added incase the user is swapping back and forth between the editor and their game in a different tab as done during testing the system; an update may not have been saved before reloading the game page, so the user would need to wait until the autosave happens.

\section{Scalable Cloud Deployment}
Deployment to Amazon Web Services was crucial in creating a scalable web application with cloud storage. This was done using the web-based AWS management console, where the Elastic Beanstalk application and EC2 instance was set up for the web server and storage server respectively.

Deploying using Elastic Beanstalk was very simple, all that was required was to create an `application' and `environment', specifying the max number of instances that can be created for load balancing and the type of instance they should be running on. For this the max instances was set to 4, which can be increased later if needed, and the instance type was set to `t2.micro' which is one of the lower tiers of instances.

When the Elastic Beanstalk environment was set up, the web server application was deployed using the EB-CLI tool, simply running the \textbf{eb deploy} command in the correct folder, which then zips the project and uploads it to Elastic Beanstalk, deploying it when it's finished.

The EC2 instance for the storage server was much more difficult to set up compared to Elastic Beanstalk. It required setting up the instance (Also t2.micro), adding the Elastic Block Storage for holding projects, then creating the security group so only the local instances could communicate with it.

SSH was used to connect to the EC2 machine to set up the machine and and install any requirements for the storage server (mongodb, python3.4, pip, virtualenv). The Elastic Block Storage volume was required to be added to the \textbf{/etc/fstab} file, making it get mounted into the \textbf{/data} directory on startup. It was also required to set MongoDB to start on boot by running \textbf{sudo chkconfig mongod on}. MongoDB was set to use the elastic block storage volume for the database storage, by changing the /etc/mongod.conf file to use the /data/mongodb folder (And setting the owner of the folder to `mongod').

After machine was fully set up, the storage server application was cloned from GitHub, and started in a GNU screen; which allows it to stay running in the background forever. The configuration for the storage server was set to use \textbf{/data/projects} folder. The storage server was then set to run on boot by adding a startup script which would create the screen, and adding the startup script to the `/etc/rc.d/rc.local' file. This file is used on Linux to specify any scripts that should be run at boot.

\section{External APIs}
Many external APIs and libraries were used in building this project, including several JavaScript libraries, Python libraries and the GitHub API. These have been listed below:

\begin{itemize}
	\itemsep-0.6em
	\item JavaScript libraries:
	\begin{itemize}
		\itemsep-0.6em
		\item Ace
		\item jQuery
		\item Bootstrap
		\item Handlebars.js
		\item Three.js
		\item Ammo.js
	\end{itemize}
	
	\item Python libraries:
	\begin{itemize}
		\itemsep-0.6em
		\item Flask
		\item Flask-Compress
		\item itsdangerous
		\item Jinja2
		\item MarkupSafe
		\item pymongo
		\item Werkzeug
		\item GitPython
		\item gitdb
		\item smmap
	\end{itemize}

	\item External APIs:
	\begin{itemize}
		\itemsep-0.6em
		\item GitHub API
	\end{itemize}
\end{itemize}

\section{List of Classes}
The following is a list of all Python, JavaScript, CSS and HTML template files that were created in the process of developing the project:

\subsubsection{Storage server}
\begin{itemize}
	\itemsep-0.6em
	\item application.py
	\item application\_tests.py
\end{itemize}
\subsubsection{Web server}
\begin{itemize}
	\itemsep-0.6em
	\item application.py
	\item storage.py
	\item github.py
	\item static/
	\begin{itemize}
		\itemsep-0.6em
		\item editor/
		\begin{itemize}
			\itemsep-0.6em
			\item editor.css
			\item editor.js
			\item selectionobject.js
			\item views/
			\begin{itemize}
				\itemsep-0.6em
				\item containerview.js
				\item editorview.js
				\item explorerscenesitemview.js
				\item explorerscenesview.js
				\item explorerscriptsitemview.js
				\item explorerscriptsview.js
				\item explorerview.js
				\item mainview.js
				\item modalinputview.js
				\item propertiesview.js
				\item sceneview.js
				\item scriptview.js
				\item tabitemview.js
				\item tabpanelview.js
				\item tabview.js
			\end{itemize}
		\end{itemize}
		\item engine/
		\begin{itemize}
			\itemsep-0.6em
			\item components.js
			\item entity.js
			\item game.js
			\item scene.js
			\item components/
			\begin{itemize}
				\itemsep-0.6em
				\item camera.js
				\item flycontroller.js
				\item fpscontroller.js
				\item light.js
				\item mesh.js
				\item physics.js
				\item transform.js
			\end{itemize}
		\end{itemize}
		\item web/
		\begin{itemize}
			\itemsep-0.6em
			\item style.css
		\end{itemize}
	\end{itemize}
	\item templates/
	\begin{itemize}
		\itemsep-0.6em
		\item editor/
		\begin{itemize}
			\itemsep-0.6em
			\item editor.html
			\item views/
			\begin{itemize}
				\itemsep-0.6em
				\item explorerscenesitemview.hbs
				\item explorerscriptsitemview.hbs
				\item modalinputview.hbs
				\item propertiesview.hbs
				\item tabitemview.hbs
				\item tabpanelview.hbs
				\item tabview.hbs
			\end{itemize}
		\end{itemize}
		\item game/
		\begin{itemize}
			\itemsep-0.6em
			\item engine.html
			\item game.html
		\end{itemize}
		\item web/
		\begin{itemize}
			\itemsep-0.6em
			\item base.html
			\item dashboard.html
			\item error.html
			\item games.html
			\item index.html
			\item nav.html
		\end{itemize}
	\end{itemize}
\end{itemize}

