\chapter{Architecture \& Development}
This chapter will go into detail of the development stages of this project, discussing the various decisions, challenges and problems faced during the development of each individual component in the system, and how they were resolved.

\section{System Overview}
The system is separated into two individual development projects, \emph{the web server} which contains the website, game engine and editor, and \emph{the storage server}. These are both web based applications which host a HTTP server through the Python-based Flask microframework. An overview of the system is shown in Figure \ref{fig:overallarchitecture}, which labels the key components of the system in red.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.8]{overallarchitecture}
	\caption{Key components in the system}
	\label{fig:overallarchitecture}
\end{figure}

\paragraph{Architectural Patterns.}
The majority of the system follows the MVC (Model-View-Controller) software architectural pattern where possible. This pattern simplifies the development of complex systems by separating the data, display and logic sections into more managable subsystems - the model, view and controller respectively. The structure and architectural pattern of each individual component in this system will be described in-depth in Section \ref{section:systemcomponents}.

% ref MVC, simplifies

\section{Development Environment}
The environment used throughout development of the project consisted of the Sublime Text 3 editor running on the Fedora 19 operating system. For each individual Flask project (The web server and storage server) a virtual environment was set up using \textbf{virtualenv}. Use of virtualenv allowed Python 3.4.2 (separate to the version on Fedora 19) and the required Python libraries to be installed individually for each project.

For both projects, Flask and it's dependencies (itsdangerous, Jinja2, MarkupSafe and Werkzeug) were installed using \textbf{pip} in the virtualenv, along with the libraries specific to each project as seen below:

\begin{itemize}
	\item Web server:
	\begin{itemize}
		\item Flask-Compress
		\item PyMongo
	\end{itemize}
	\item Storage server:
	\begin{itemize}
		\item GitPython and dependencies (gitdb, smmap)
	\end{itemize}
\end{itemize}

The tools required to manage the Amazon Web Services were also installed in this environment, including the AWS CLI (Command Line Interface), and the Elastic Beanstalk CLI. These tools allow remote management of all AWS resources and quick deployment of applications to the Elastic Beanstalk platform.

The Git version control system was used to manage the project in this environment, with the project repository being hosted on GitHub as an external backup source. Originally, the two projects were in the same Git repository, however this proved to be unsuitable as rolling back changes on one project would be troublesome. The two projects were split into their own Git repositories using the \textbf{git subtree split} command, which maintained all commit history relevant to each project.

\section{System Components}
\label{section:systemcomponents}
	\subsection{Web Server}
	The web server is the core part of the system, where all user requests are handled. Everything the user does on the system goes through the web server, so it must be able to handle a lot of users. For this reason the lightweight `microframework' \emph{Flask} was chosen as the base of the server. %todo more

	\paragraph{Architectural Pattern.}
	The Flask application created for the web server uses a software architectural pattern \emph{similar} to the MVC pattern. Flask lends itself well to the MVC pattern; as each page has it's own route (\textbf{Controller}) and template (\textbf{View}), with the route generally populating the template with data (\textbf{Model}). This can be seen visualised in Figure \ref{fig:flaskprocess} which demonstrates how a request is handled by Flask. A client sends a request to the route, the route then retrieves any requested data (Such as a list of published games), then it renders the template for that route with the data. The generated HTML from the template is sent back as the HTTP response.

	\begin{figure}[h]
		\centering
		\includegraphics[scale=0.8]{flaskprocess}
		\caption{The Flask request process}
		\label{fig:flaskprocess}
	\end{figure}

	\paragraph{GitHub Authorisation.}


	\paragraph{Templates.}
	HTML templates are used to render the pages the server sends to the client. These are created using the Jinja2 templating language which is similar to embedding Python in HTML. Jinja2 has the feature of allowing templates to \emph{extend} or \emph{include} other templates, this means that they can be built upon eachother so very little HTML is repeated throughout the files. 

	The template structure used for this website is built by extending a `base' template, which makes the creation of a consistently designed website easy. The base template creates the `html', `head' and `body' tags, links the stylesheets, adds a footer, then includes the `nav' template which has the top bar containing links to all of pages on the website. The rest of the body of the base template is defined as an empty `block'; which can be redefined by a template extending the base (Seen below).
	\lstset{language=HTML,frame=single}
	\begin{lstlisting}
{% block content %}{% endblock %}
	\end{lstlisting}

	The nav template uses conditionals in Jinja2 to programmatically change how the navigation bar is displayed to the user; it does this by accessing the session variable on the server to check if the user has logged in. When a user is logged in, they are shown the link to the dashboard, along with their avatar, name and a `log out' button. If a user isn't logged in then the `log in' button is shown. This can be seen below:

	\begin{lstlisting}
{% if 'access_token' in session %}
	<div class="userbox">
	<img src="{{session['user_info']['avatar_url']}}&amp;s=30" alt="">
	{{ session['user_info']['name'] }} 
	<a href="/logout">logout</a>
	</div>
{% else %}
	<form 
		action="https://github.com/login/oauth/authorize" method="get">
		<button type="submit" class="btn btn-default">
			Log in with GitHub
		</button>
		<input type="hidden" name="scope" value="{{config.GITHUB_SCOPES}}"/>
		<input type="hidden" name="client_id" value="{{config.GITHUB_CLIENT_ID}}"/>
	</form>
{% endif %}
	\end{lstlisting}

	\subsubsection{Routes}
	The development of this component of the system consisted of developing each URL that users could access on the website. These took the form as routes in the Flask application, designated with a URL containing variables (Denoted with <>), along with HTML templates that get rendered with data from the server (However not every route has a template).
	% todo
	% A paragraph for each route.

	\paragraph{/}
	\paragraph{/games}
	\paragraph{/game/<user>/<repo>}
	\paragraph{/login}
	\paragraph{/logout}
	\paragraph{/dashboard}
	\paragraph{/editor/<repo>}


	% - Communication with storage server{storing remote access_token etc}
	% - GitHub API, login access_token, emails, list of repos for cloning etc
	% - Connecting to MongoDB on storage server
	% Config files
	% Every route
		% Login shit etc
		% Talking to storage for dashboard
		% Game engine, discuss how the template loads all JS, JSON etc

	\subsection{Storage Server}
	% What it is. It's a restful API for accessing files.
	The storage server is where all user created games are stored and retrieved. The storage 
	% each route outputs JSON, even on failure
	% - Why this was it's own server
	The development of a separate server for storing and retrieving files was determined to be necessary to allow for the automatic scaling of the web application

	\paragraph{Architectural Pattern.}
	The software pattern used for the storage server is similar to the MVC system generally used in Flask, however MVC is suited towards applications that have a user interface; a `view'. In this case the JSON output by the RESTful API could be considered the view, with the controller being routes and the model being the file structures.
	% - Pattern - MVC-like
	% - restful API, flask app
		% - GitPython usage
		% - git operations, access_token, remotes
	% - Talk about each API route individually
	% Config files

	% - mongodb
	\subsection{Game Engine}
	% - ECS pattern
	% - "Game" object.
	% - Loading from JSON, initialization
	% - Walkthrough of how the process works. Setting up renderer in Game, updating all scenes with deltatime, updating all entities, updating all components.
	% - Adding, removing components
	% - Using Three.js - setting up the renderer, setting up the Scene to add threeobjs as they are added
	% - Using Ammo.js - Setting up the world, gravity etc, adding ammoobjs as they are added
	% - Simplifying the two libraries into the ECS architecture, predefined components
	% 	This was achieved by etc.
	% - Each pre-defined component
	\subsection{Game Editor}
	% - Pseudo MVC microframework
		% Looked at frameworks, all too heavy
		% Just made my own to keep it simple, based on something similar to backbone
	% - Detail each view
	% - Scene view - 
			% How it loads the gamedata, selection object
	% - Tying in the game engine with the storage backend
	% - Properties of both the gamedata json and the displayed game entities
	% - Scripts, Ace editor
	% - autosaving
	\subsection{Scalable Cloud Deployment}
	% - Setting up AWS
	% - Load balancing, separating web from storage
	% - SSH, Git, tools
	% - Deploying to Elastic Beanstalk {eb cli}
	% - Storage server {Setting up MongoDB, git, cloning the storage repo}
		% - Deployment was difficult compared to Elastic Beanstalk (used git to deploy latest version)

\section{Deployment to AWS}
% How everything was deployed etc

\section{Key Development Components}
% Identify key development components
% Key components were the game engine, editor, web server (load balancing) and storage.
% Git integration wasn't as important to functionality

\section{External APIs}
% Indentification/explanation of external APIs used vs own code. 

\section{List of Classes}
% List of classes of your code
% Write block comments for code during this process?